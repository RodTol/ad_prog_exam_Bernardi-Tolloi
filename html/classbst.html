<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Binary Search Tree: bst&lt; key_type, value_type, OP &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Binary Search Tree
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classbst-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">bst&lt; key_type, value_type, OP &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="bst_8hpp_source.html">bst.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1ba2723ef9d9c08073bd2fcb91ad5d52"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#a1ba2723ef9d9c08073bd2fcb91ad5d52">bst</a> ()=default</td></tr>
<tr class="separator:a1ba2723ef9d9c08073bd2fcb91ad5d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16749f7d69c12e6bf94a41a96cdfbcc4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#a16749f7d69c12e6bf94a41a96cdfbcc4">~bst</a> ()=default</td></tr>
<tr class="separator:a16749f7d69c12e6bf94a41a96cdfbcc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f31521b77882d5b84bea8cc7be14d2b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#a6f31521b77882d5b84bea8cc7be14d2b">bst</a> (attr_type starting_attr) noexcept</td></tr>
<tr class="separator:a6f31521b77882d5b84bea8cc7be14d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8906a1dacad0796fb1e50a22bf8d728"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#ab8906a1dacad0796fb1e50a22bf8d728">bst</a> (const <a class="el" href="classbst.html">bst</a> &amp;tree_to_copy)</td></tr>
<tr class="separator:ab8906a1dacad0796fb1e50a22bf8d728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705b03435d0b5ce26fed2d6296cdfd30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbst.html">bst</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#a705b03435d0b5ce26fed2d6296cdfd30">operator=</a> (const <a class="el" href="classbst.html">bst</a> &amp;tree_to_copy)</td></tr>
<tr class="separator:a705b03435d0b5ce26fed2d6296cdfd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262f7f3c644646495f31b9d960953f9d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#a262f7f3c644646495f31b9d960953f9d">bst</a> (<a class="el" href="classbst.html">bst</a> &amp;&amp;tree_to_copy)</td></tr>
<tr class="separator:a262f7f3c644646495f31b9d960953f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570acf5ff851245509787b98c6a088e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbst.html">bst</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#a570acf5ff851245509787b98c6a088e8">operator=</a> (<a class="el" href="classbst.html">bst</a> &amp;&amp;tree_to_copy)</td></tr>
<tr class="separator:a570acf5ff851245509787b98c6a088e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c4bccff1bbb655aceab7eb4a1bdce6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#a68c4bccff1bbb655aceab7eb4a1bdce6">begin</a> () noexcept</td></tr>
<tr class="separator:a68c4bccff1bbb655aceab7eb4a1bdce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46573bbd88ab58ada60918a89547cd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#ae46573bbd88ab58ada60918a89547cd4">begin</a> () const noexcept</td></tr>
<tr class="separator:ae46573bbd88ab58ada60918a89547cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4fb338300a01aa44b5314bf42a9f7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#a2b4fb338300a01aa44b5314bf42a9f7a">cbegin</a> () const noexcept</td></tr>
<tr class="separator:a2b4fb338300a01aa44b5314bf42a9f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4499987393d029835b0a888808d4857"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#af4499987393d029835b0a888808d4857">tail</a> () noexcept</td></tr>
<tr class="separator:af4499987393d029835b0a888808d4857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa543a69847d308ab201590c9e3a7108e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#aa543a69847d308ab201590c9e3a7108e">tail</a> () const noexcept</td></tr>
<tr class="separator:aa543a69847d308ab201590c9e3a7108e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a181d94256736e8c64d17e5542d2313"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#a0a181d94256736e8c64d17e5542d2313">ctail</a> () const noexcept</td></tr>
<tr class="separator:a0a181d94256736e8c64d17e5542d2313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ce6fbe3c3fe23fbbe7fb1b15587a61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#aa6ce6fbe3c3fe23fbbe7fb1b15587a61">end</a> () noexcept</td></tr>
<tr class="separator:aa6ce6fbe3c3fe23fbbe7fb1b15587a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9553c9a0db32dffaf4a08a75901cf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#afb9553c9a0db32dffaf4a08a75901cf3">end</a> () const noexcept</td></tr>
<tr class="separator:afb9553c9a0db32dffaf4a08a75901cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a899c6c53d3f500622be93c8a43f874"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#a4a899c6c53d3f500622be93c8a43f874">cend</a> () const noexcept</td></tr>
<tr class="separator:a4a899c6c53d3f500622be93c8a43f874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f641935e5e7681a57caedc2760d6ec8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#a6f641935e5e7681a57caedc2760d6ec8">find</a> (const key_type &amp;x)</td></tr>
<tr class="separator:a6f641935e5e7681a57caedc2760d6ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6376acbafc21936af61b7a55f52073"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#a2a6376acbafc21936af61b7a55f52073">find</a> (const key_type &amp;x) const</td></tr>
<tr class="separator:a2a6376acbafc21936af61b7a55f52073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba320a5c0ba3667edff6e2b70651cc3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="struct__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#aaba320a5c0ba3667edff6e2b70651cc3">insert</a> (const attr_type &amp;x)</td></tr>
<tr class="separator:aaba320a5c0ba3667edff6e2b70651cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204c871743b5cc278da1414fac52c9eb"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="struct__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#a204c871743b5cc278da1414fac52c9eb">insert</a> (attr_type &amp;&amp;x)</td></tr>
<tr class="separator:a204c871743b5cc278da1414fac52c9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac411e2594cb65ecdeae5e95451a63b57"><td class="memTemplParams" colspan="2">template&lt;class... Types&gt; </td></tr>
<tr class="memitem:ac411e2594cb65ecdeae5e95451a63b57"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="struct__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbst.html#ac411e2594cb65ecdeae5e95451a63b57">emplace</a> (Types &amp;&amp;... args)</td></tr>
<tr class="separator:ac411e2594cb65ecdeae5e95451a63b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cad294400509550f2390471e7063cbf"><td class="memItemLeft" align="right" valign="top">value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#a9cad294400509550f2390471e7063cbf">operator[]</a> (const key_type &amp;x)</td></tr>
<tr class="separator:a9cad294400509550f2390471e7063cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d15cc71b1cbb1f758f574d6455d3afb"><td class="memItemLeft" align="right" valign="top">value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#a5d15cc71b1cbb1f758f574d6455d3afb">operator[]</a> (key_type &amp;&amp;x)</td></tr>
<tr class="separator:a5d15cc71b1cbb1f758f574d6455d3afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b490d1bcf24de6e973772d482883239"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#a1b490d1bcf24de6e973772d482883239">clear</a> ()</td></tr>
<tr class="separator:a1b490d1bcf24de6e973772d482883239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d8e241afdd789f6fc4f4895fd3c28f"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#ae5d8e241afdd789f6fc4f4895fd3c28f">size</a> ()</td></tr>
<tr class="separator:ae5d8e241afdd789f6fc4f4895fd3c28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616594a73f55c43f4eb8b9c661b84695"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#a616594a73f55c43f4eb8b9c661b84695">balance</a> ()</td></tr>
<tr class="separator:a616594a73f55c43f4eb8b9c661b84695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811b688d9f0214ebfe42ec78178c4f37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#a811b688d9f0214ebfe42ec78178c4f37">balance</a> (std::vector&lt; attr_type &gt; &amp;tmp, std::size_t left, std::size_t right) noexcept</td></tr>
<tr class="separator:a811b688d9f0214ebfe42ec78178c4f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40bdf0304375dde85c60bbc5e7bcb59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnode.html">node</a>&lt; attr_type &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#ac40bdf0304375dde85c60bbc5e7bcb59">min_sub</a> (<a class="el" href="structnode.html">node</a>&lt; attr_type &gt; *start)</td></tr>
<tr class="separator:ac40bdf0304375dde85c60bbc5e7bcb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6e04b1567158f477d0489700c5bf50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#a2c6e04b1567158f477d0489700c5bf50">erase</a> (const key_type &amp;x)</td></tr>
<tr class="separator:a2c6e04b1567158f477d0489700c5bf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a8629b96d895ff3e69fc15f3e2682a841"><td class="memItemLeft" align="right" valign="top"><a id="a8629b96d895ff3e69fc15f3e2682a841"></a>
std::unique_ptr&lt; <a class="el" href="structnode.html">node</a>&lt; attr_type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>head</b></td></tr>
<tr class="separator:a8629b96d895ff3e69fc15f3e2682a841"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a9d3bddf1057758177152348838e076eb"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbst.html#a9d3bddf1057758177152348838e076eb">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classbst.html">bst</a> &amp;x) noexcept</td></tr>
<tr class="separator:a9d3bddf1057758177152348838e076eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename key_type, typename value_type, typename OP = std::less&lt;key_type&gt;&gt;<br />
class bst&lt; key_type, value_type, OP &gt;</h3>

<p>Author: Rodolfo Tolloi, Giulia Bernardi.</p>
<p>Purpouse: create a custom class that represents a binary search tree (bst). This is done by defining a compare operator and a head. The first is the relation that will decide where a new node will insert, while the second is a unique pointer to the first node of the tree.</p>
<p>Date: May, 2021. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1ba2723ef9d9c08073bd2fcb91ad5d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba2723ef9d9c08073bd2fcb91ad5d52">&#9670;&nbsp;</a></span>bst() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::<a class="el" href="classbst.html">bst</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor </p>

</div>
</div>
<a id="a16749f7d69c12e6bf94a41a96cdfbcc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16749f7d69c12e6bf94a41a96cdfbcc4">&#9670;&nbsp;</a></span>~bst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::~<a class="el" href="classbst.html">bst</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default destructor </p>

</div>
</div>
<a id="a6f31521b77882d5b84bea8cc7be14d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f31521b77882d5b84bea8cc7be14d2b">&#9670;&nbsp;</a></span>bst() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::<a class="el" href="classbst.html">bst</a> </td>
          <td>(</td>
          <td class="paramtype">attr_type&#160;</td>
          <td class="paramname"><em>starting_attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Custom constructor, who take a attribute and create a node which will be the first of a bst. </p>

</div>
</div>
<a id="ab8906a1dacad0796fb1e50a22bf8d728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8906a1dacad0796fb1e50a22bf8d728">&#9670;&nbsp;</a></span>bst() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::<a class="el" href="classbst.html">bst</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree_to_copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor </p>

</div>
</div>
<a id="a262f7f3c644646495f31b9d960953f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a262f7f3c644646495f31b9d960953f9d">&#9670;&nbsp;</a></span>bst() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::<a class="el" href="classbst.html">bst</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>tree_to_copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a616594a73f55c43f4eb8b9c661b84695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616594a73f55c43f4eb8b9c661b84695">&#9670;&nbsp;</a></span>balance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::balance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>balance: function that will balance the tree, rewriting it with roughly half of the nodes on the left and the other half on the right. This first overloading create a orderd vector "tmp" by taking the attributes of the nodes in the traversal order. After that it will call the clear function, erasing the content of the tree. In the end it will call the second overloding which will create the ordered tree. </p>

</div>
</div>
<a id="a811b688d9f0214ebfe42ec78178c4f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a811b688d9f0214ebfe42ec78178c4f37">&#9670;&nbsp;</a></span>balance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::balance </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; attr_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>balance: this second overloading of the balance function will take a input vector of attributes and use the insert function to create the nodes such that the tree will be balanced. To achieve so, it will start by inserting the node in the middle of the vector (or the roundown value if the size of the vector is odd). Than it will repeat the same process for one half of the vector, inserting an another node, and by iterating this process it will create the balanced tree. </p>

</div>
</div>
<a id="ae46573bbd88ab58ada60918a89547cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46573bbd88ab58ada60918a89547cd4">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__iterator.html">const_iterator</a> <a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begin: this function will return a const iterator to the leftmost node of the const tree. </p>

</div>
</div>
<a id="a68c4bccff1bbb655aceab7eb4a1bdce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c4bccff1bbb655aceab7eb4a1bdce6">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__iterator.html">iterator</a> <a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begin: this function will return an iterator to the leftmost node of the non-const tree. </p>

</div>
</div>
<a id="a2b4fb338300a01aa44b5314bf42a9f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4fb338300a01aa44b5314bf42a9f7a">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__iterator.html">const_iterator</a> <a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cbegin: it will always return a const_iterator to the leftmost node of the tree. </p>

</div>
</div>
<a id="a4a899c6c53d3f500622be93c8a43f874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a899c6c53d3f500622be93c8a43f874">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__iterator.html">const_iterator</a> <a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>cend: it will return a const_iterator to one-past the last element, both for const and non-const tree. </p>

</div>
</div>
<a id="a1b490d1bcf24de6e973772d482883239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b490d1bcf24de6e973772d482883239">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>clear: this function clear the content of the tree by resetting the head pointer to nullptr </p>

</div>
</div>
<a id="a0a181d94256736e8c64d17e5542d2313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a181d94256736e8c64d17e5542d2313">&#9670;&nbsp;</a></span>ctail()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__iterator.html">const_iterator</a> <a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::ctail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ctail: it will return a const_iterator to the rightmost node of the tree, both for const and non-const tree. </p>

</div>
</div>
<a id="ac411e2594cb65ecdeae5e95451a63b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac411e2594cb65ecdeae5e95451a63b57">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="struct__iterator.html">iterator</a>,bool&gt; <a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Types &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Emplace: this function tries to create one or more element if there is no element with the same key. </p>

</div>
</div>
<a id="afb9553c9a0db32dffaf4a08a75901cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb9553c9a0db32dffaf4a08a75901cf3">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__iterator.html">const_iterator</a> <a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>End: it will return a const iterator to one-past the last element of the const tree. </p>

</div>
</div>
<a id="aa6ce6fbe3c3fe23fbbe7fb1b15587a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6ce6fbe3c3fe23fbbe7fb1b15587a61">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__iterator.html">iterator</a> <a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>End: it will return an iterator to one-past the last element of the tree. </p>

</div>
</div>
<a id="a2c6e04b1567158f477d0489700c5bf50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c6e04b1567158f477d0489700c5bf50">&#9670;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>erase: this function purpouse is to remove a node with key equal to the the input (if it exist). The first step is to check if this node exist. There are 3 case: the node has no child, has one child (left or right) and has both child. For the first case the function simply remove the node by resetting the father's pointer and the objective node's parent pointer. For the second case it will also connect the father node to the children, preserving the structure of the tree. The last case is solved by moving the left subtree of the objective node to the leftmost element of the right subtree of the objective node. Thanks to this operation, the node will have only a right child, and so the problem can be solved as explained above. </p>

</div>
</div>
<a id="a6f641935e5e7681a57caedc2760d6ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f641935e5e7681a57caedc2760d6ec8">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__iterator.html">iterator</a> <a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find: search a node with key equal to the input, and if it succed return a iterator to the node, otherwise, it will return a iterator to nullptr. </p>

</div>
</div>
<a id="a2a6376acbafc21936af61b7a55f52073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6376acbafc21936af61b7a55f52073">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__iterator.html">const_iterator</a> <a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find: search a node with key equal to the input, and if it succed return a const_iterator to the node, otherwise, it will return a const_iterator to nullptr. </p>

</div>
</div>
<a id="a204c871743b5cc278da1414fac52c9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204c871743b5cc278da1414fac52c9eb">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="struct__iterator.html">iterator</a>, bool&gt; <a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">attr_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert: this function tries to create a node with the attribute equal to the input x. It return a pair made by a boolean and a iterator. The boolean is false if the node with key = x already exist, true if the node must be created. The iterator point to the node both if it was just created or it was already there. This formulation is for r-values </p>

</div>
</div>
<a id="aaba320a5c0ba3667edff6e2b70651cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba320a5c0ba3667edff6e2b70651cc3">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="struct__iterator.html">iterator</a>, bool&gt; <a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const attr_type &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert: this function tries to create a node with the key equal to the input x. It return a pair made by a boolean and a iterator. The boolean is false if the node with key = x already exist, true if the node must be created. The iterator point to the node both if it was just created or it was already there. This formulation is for l-values </p>

</div>
</div>
<a id="ac40bdf0304375dde85c60bbc5e7bcb59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40bdf0304375dde85c60bbc5e7bcb59">&#9670;&nbsp;</a></span>min_sub()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnode.html">node</a>&lt;attr_type&gt;* <a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::min_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnode.html">node</a>&lt; attr_type &gt; *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>min_sub: this function return a pointer to the leftmost node of the subtree of a input node. </p>

</div>
</div>
<a id="a570acf5ff851245509787b98c6a088e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a570acf5ff851245509787b98c6a088e8">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbst.html">bst</a>&amp; <a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>tree_to_copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move assignement </p>

</div>
</div>
<a id="a705b03435d0b5ce26fed2d6296cdfd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705b03435d0b5ce26fed2d6296cdfd30">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbst.html">bst</a>&amp; <a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree_to_copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy assignement </p>

</div>
</div>
<a id="a9cad294400509550f2390471e7063cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cad294400509550f2390471e7063cbf">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_type&amp; <a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>subscripting operator: this function returns a reference to the value of the node with the key equal to the input x, performing a insertion if that key does not already exist. This formulation is for l-value </p>

</div>
</div>
<a id="a5d15cc71b1cbb1f758f574d6455d3afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d15cc71b1cbb1f758f574d6455d3afb">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_type&amp; <a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">key_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>subscripting operator: this function returns a reference to the value of the node with the key equal to the input x, performing a insertion if that key does not already exist. This formulation is for r-value </p>

</div>
</div>
<a id="ae5d8e241afdd789f6fc4f4895fd3c28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d8e241afdd789f6fc4f4895fd3c28f">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>size: function that returns the number of nodes inside the tree </p>

</div>
</div>
<a id="aa543a69847d308ab201590c9e3a7108e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa543a69847d308ab201590c9e3a7108e">&#9670;&nbsp;</a></span>tail() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__iterator.html">const_iterator</a> <a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::tail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tail: it will return a const_iterator to the rightmost node of the const tree. </p>

</div>
</div>
<a id="af4499987393d029835b0a888808d4857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4499987393d029835b0a888808d4857">&#9670;&nbsp;</a></span>tail() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__iterator.html">iterator</a> <a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt;::tail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tail: it will return a iterator to the rightmost node of the non const tree. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a9d3bddf1057758177152348838e076eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d3bddf1057758177152348838e076eb">&#9670;&nbsp;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename OP  = std::less&lt;key_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbst.html">bst</a>&lt; key_type, value_type, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>put-to: custom overloading of put-to operator that will print the tree following the traversal. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="bst_8hpp_source.html">bst.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
